/**
 * @file ip_address.cpp
 * @brief Реализация работы с IP-адресами
 * 
 * Этот модуль содержит базовые операции для работы с IP-адресами:
 * - Парсинг из строки
 * - Сравнение для сортировки
 * - Проверка условий (для использования в предикатах)
 * - Вывод в поток
 */

#include "ip_address.h"
#include <stdexcept>
#include <ostream>

// ============================================================================
// МЕТОДЫ СТРУКТУРЫ IpAddress
// ============================================================================

/**
 * @brief Оператор сравнения для сортировки в обратном лексикографическом порядке
 * 
 * ВАЖНО: Это обратное сравнение (по убыванию), а не обычное (по возрастанию).
 * 
 * Логика работы:
 * - Сравниваем октеты слева направо (от первого к четвертому)
 * - Если октеты различаются, возвращаем true, если левый БОЛЬШЕ правого
 * - Это создает сортировку по убыванию: 46.70.1.1 > 1.10.1.1 > 1.2.1.1 > 1.1.1.1
 * 
 * Пример:
 *   IpAddress(1, 10, 1, 1) < IpAddress(1, 2, 1, 1)  // true, т.к. 10 > 2
 *   Результат сортировки: [1.10.1.1, 1.2.1.1, 1.1.1.1]
 * 
 * @param other Другой IP-адрес для сравнения
 * @return true если this должен идти ПЕРЕД other при сортировке (this > other)
 */
bool IpAddress::operator<(const IpAddress& other) const {
    // Сравниваем октеты по порядку
    for (int i = 0; i < 4; ++i) {
        if (octets[i] != other.octets[i]) {
            // Обратное сравнение: возвращаем true, если наш октет БОЛЬШЕ
            // Это создает сортировку по убыванию
            return octets[i] > other.octets[i];
        }
    }
    // Все октеты равны - адреса одинаковые
    return false;
}

/**
 * @brief Проверяет, равен ли октет под указанным индексом заданному значению
 * 
 * Используется в предикатах для проверки конкретных октетов.
 * 
 * @param idx Индекс октета (0-3, где 0 - первый октет)
 * @param value Значение для сравнения
 * @return true если октет[idx] == value
 * 
 * Пример:
 *   ip.octetEquals(0, 1)  // Проверяет, равен ли первый октет единице
 *   ip.octetEquals(1, 46) // Проверяет, равен ли второй октет 46
 */
bool IpAddress::octetEquals(int idx, uint8_t value) const {
    return octets[idx] == value;
}

/**
 * @brief Проверяет, содержит ли адрес октет с заданным значением
 * 
 * Проверяет все 4 октета, возвращает true, если хотя бы один равен value.
 * Используется для фильтрации адресов, содержащих определенное значение в любом месте.
 * 
 * @param value Значение для поиска
 * @return true если хотя бы один октет равен value
 * 
 * Пример:
 *   IpAddress(192, 46, 1, 1).contains(46)  // true (второй октет = 46)
 *   IpAddress(46, 70, 1, 1).contains(46)   // true (первый октет = 46)
 *   IpAddress(1, 1, 1, 1).contains(46)     // false
 */
bool IpAddress::contains(uint8_t value) const {
    for (int i = 0; i < 4; ++i) {
        if (octets[i] == value) return true;
    }
    return false;
}

// ============================================================================
// ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ
// ============================================================================

/**
 * @brief Оператор вывода IP-адреса в поток
 * 
 * Форматирует адрес в стандартный вид: "a.b.c.d"
 * Каждый октет выводится как целое число (не как символ).
 * 
 * @param os Поток вывода
 * @param ip IP-адрес для вывода
 * @return Ссылка на поток для цепочки операций
 * 
 * Пример:
 *   IpAddress ip(192, 168, 1, 1);
 *   std::cout << ip;  // Выведет: "192.168.1.1"
 */
std::ostream& operator<<(std::ostream& os, const IpAddress& ip) {
    // static_cast<int> нужен, чтобы вывести число, а не символ
    // (uint8_t может интерпретироваться как char)
    os << static_cast<int>(ip.octets[0]) << "."
       << static_cast<int>(ip.octets[1]) << "."
       << static_cast<int>(ip.octets[2]) << "."
       << static_cast<int>(ip.octets[3]);
    return os;
}

/**
 * @brief Парсинг IP-адреса из строки вида "a.b.c.d"
 * 
 * Упрощенный и эффективный парсинг через string::find вместо stringstream.
 * Алгоритм:
 * 1. Ищем точки в строке последовательно
 * 2. Извлекаем подстроки между точками
 * 3. Преобразуем каждую подстроку в число (октет)
 * 
 * @param ipStr Строка с IP-адресом в формате "a.b.c.d"
 * @return Структура IpAddress с распарсенными октетами
 * @throws std::invalid_argument если формат строки неверный
 * 
 * Примеры:
 *   parseIp("192.168.1.1")  -> IpAddress(192, 168, 1, 1)
 *   parseIp("1.2.3")        -> исключение (не хватает октета)
 *   parseIp("1.2.3.4.5")    -> исключение (лишние октеты)
 */
IpAddress parseIp(const std::string& ipStr) {
    uint8_t octets[4];
    size_t start = 0;  // Позиция начала текущего октета
    
    // Парсим 4 октета
    for (int i = 0; i < 4; ++i) {
        size_t dotPos = ipStr.find('.', start);
        
        // Для последнего (четвертого) октета точки быть не должно
        if (i == 3) {
            // Если нашли точку после четвертого октета - это ошибка
            if (dotPos != std::string::npos) {
                throw std::invalid_argument("Неверный формат IP-адреса: " + ipStr);
            }
            // Извлекаем последний октет до конца строки
            std::string part = ipStr.substr(start);
            octets[i] = static_cast<uint8_t>(std::stoi(part));
            break;
        }
        
        // Для первых трех октетов точка обязательна
        if (dotPos == std::string::npos) {
            throw std::invalid_argument("Неверный формат IP-адреса: " + ipStr);
        }
        
        // Извлекаем подстроку от start до точки (не включая точку)
        std::string part = ipStr.substr(start, dotPos - start);
        octets[i] = static_cast<uint8_t>(std::stoi(part));
        
        // Следующий октет начинается после точки
        start = dotPos + 1;
    }
    
    return IpAddress(octets[0], octets[1], octets[2], octets[3]);
}

/**
 * @brief Извлечение первого столбца из строки, разделенной табуляцией
 * 
 * Входные данные имеют формат: "ip_address\tcolumn2\tcolumn3"
 * Нам нужен только первый столбец (IP-адрес).
 * 
 * @param line Строка с данными, разделенными табуляцией
 * @return Первый столбец (подстрока до первой табуляции или вся строка, если табуляции нет)
 * 
 * Примеры:
 *   extractFirstColumn("192.168.1.1\t111\t0")  -> "192.168.1.1"
 *   extractFirstColumn("192.168.1.1")          -> "192.168.1.1"
 */
std::string extractFirstColumn(const std::string& line) {
    size_t tabPos = line.find('\t');
    if (tabPos != std::string::npos) {
        // Нашли табуляцию - возвращаем подстроку до неё
        return line.substr(0, tabPos);
    }
    // Табуляции нет - возвращаем всю строку
    return line;
}

